## Main





## Game Object

### Game Object

### Actor

### Map

### Rect

### Test Object1

### Test Object2

### Test Object3





## Scene

### Scene

### OpenScene

### GameScene



## Controllers

### Audio Resource Controller

### Image Controller

### Scene Controller



## Utils

### Command Solver

### Delay
這個類別的目的是當我們希望物件的動作延遲時使用，比如說我們不會希望人物每秒走60步，此時就可以用delay延遲走路的動作。

```java

public class Delay {
    private int count; //計時器，計算當下經過的幀數
    private int countLimit;// 計數的上限(總共要計時幾幀)
    private boolean isPause;//是否暫停計數
    private boolean isLoop;//是否進行週期性的延遲
    //建構子
    public Delay(int countLimit){
        this.countLimit=countLimit;
        count=0;
        isPause=true; //剛開始的時候沒有要計時
        isLoop=false; //剛開始不要週期性延遲，需要時再用
    }

    //方法區
    //停止計時的方法
    public void stop(){
        count=0; //計時器歸0
        this.isPause=true; //暫停計時
    }
    //開始計時
    public void play(){
        this.isPause=false;
    }
    //執行週期延遲
    public void loop(){
        this.isLoop=true; //開始週期延遲
        this.isPause=false; //不要暫停
    }
    //暫停計時
    public void pause(){
        this.isPause=true;
    }
    //是否未開始延遲
    public boolean isStop(){
        return count==0 && isPause; //計數器是0的時候，且是暫停的狀態-->表示還沒開始計時
    }
    //是否正在延遲中
    public boolean isPlaying(){
        return !this.isPause; //非暫停，就是在延遲中
    }
    //是否是暫停的狀態
    public boolean isPause(){
        return isPause;
    }


    // 這個方法需要反覆在更新中被呼叫，並通過被呼叫的次數來進行延遲的判斷
    public boolean count(){  //會回傳是否觸發目標動作的計時器
        if(isPause){ //假如現在是暫停計時狀態
            return false; //即不會計算也不會觸發延遲後要執行的事件
        }
        if(count>=countLimit){ //假如計數計到大於等於計數上限時
            if(this.isLoop){
                // 如果是週期性執行的情況就重新將count歸零繼續計算
                this.count = 0;
            }else {
                this.stop(); //就停止計數
            }
            return true;  //觸發我們要的動作
        }
        count++; //計時
        return false;   //還不要觸發我們要的動作
    }
}
```
加入delay物件並初始化

```java
private Delay delay;//在需要delay的類別加入delay屬性，譬如人物走路的類

private ActorAnimal(){
            delay=new Delay(5);//放入要計時幾次
            delay.loop();//如果希望計時會一直重複用loop()
    		delay.play();//希望計時只進行一次用play()
        }
```

在需要delay的方法加入delay.count()

```java
 if (delay.count()){//delay計時完成會回傳一個true，此時進行動作
     //在if裡放delay結束後做的動作
                }
```



### GameKernel

### Global

需要共用或是重覆使用的東西、資料都可以設為static放在global類別內，減少記憶體使用。

<u>Global中的 InternetCommand:</u>

在使用網路連線封包時會因為連線狀態不同而需要做不同的事情，因此需要定義目前連線狀態以便後續動作執行

```java
public class Global {
		public class InternetCommand{
				public static final int CONNECT = 0;
				public static final int MOVE = 1;
				public static final int DISCONNECT = 2;
		}
}
ClientClass.getInstance().consume(new CommandReceiver() {
                @Override
                public void receive(int serialNum, int internetcommand, ArrayList<String> strs) {
                  	//因應不同的連線狀態，用switch case執行不同的事件
                    switch(internetcommand){
                        case **Global.InternetCommand.CONNECT:**
                            System.out.println("Connect " + serialNum);
                            boolean isBorn = false;
                            for (int i = 0; i < aliens.size(); i++) {
                                if (aliens.get(i).getId() == serialNum) {
                                    isBorn = true;
                                    break;
                                }
                            }
                            if(!isBorn) {
                                aliens.add(new Alien(Integer.valueOf(strs.get(0)), Integer.valueOf(strs.get(1)), Integer.valueOf(strs.get(2))));
                                aliens.get(aliens.size() - 1).setId(serialNum);
                                ArrayList<String> str=new ArrayList<>();
                                str.add(aliens.get(0).painter().centerX()+"");
                                str.add(aliens.get(0).painter().centerY()+"");
                                str.add(aliens.get(0).getNum()+"");
                                ClientClass.getInstance().sent(Global.InternetCommand.CONNECT,str);
                            }
                            break;
                        case **Global.InternetCommand.MOVE:**
                            for(int i=1;i<aliens.size();i++) {
                                if(aliens.get(i).getId()==Integer.valueOf(strs.get(0))) {
                                    aliens.get(i).painter().setCenter(Integer.valueOf(strs.get(1)),Integer.valueOf(strs.get(2)));
                                    if(aliens.get(i).getHorizontalDir() == Global.Direction.LEFT || aliens.get(i).getHorizontalDir() == Global.Direction.RIGHT) {
                                        aliens.get(i).setHorizontalDir(Global.Direction.getDirection(Integer.valueOf(strs.get(3))));
                                    }
                                    if(aliens.get(i).getVerticalDir() == Global.Direction.DOWN || aliens.get(i).getVerticalDir() == Global.Direction.UP){
                                        aliens.get(i).setVerticalDir(Global.Direction.getDirection(Integer.valueOf(strs.get(3))));
                                    }
                                    break;
                                }
                            }
                            break;
                        case **Global.InternetCommand.DISCONNECT:**
                            for(int i=0;i<aliens.size();i++){
                                if(aliens.get(i).getId()==Integer.valueOf(strs.get(0))){
                                    aliens.remove(i);
                                }
                            }
                            break;
                    }
                }
            });
        }
```

<u>Global中的 Direction:</u>

若角色(玩家、敵人...等)需要用到方位判斷時，就會需要用到Direction，因此寫在global方便使用。

```java
public class Global {
		public enum Direction {
        UP(3),
        DOWN(0),
        LEFT(1),
        RIGHT(2),
        NO_DIR(4);
        private int value;
				
      	//在Direction的建構子中帶入commandCode數值，讓commandCode與方向做連結
        Direction(int value) {
            this.value = value;
        }
      
      	//讓使用者能用狀態找到相對應的commandCode
        public int getValue() {
            return value;
        }
				
      	//讓使用者用commandCode找到相對應的狀態
        public static Direction getDirection(int value){
            for(Direction d : Direction.values()){
                if(d.getValue() == value){
                    return d;
                }
            }
            return Direction.NO_DIR;
        }
    }
}
```

<u>Global中的 isDebug:</u>

藉由設定IS_DEBUG = true 可以得到各個物件的painter框，以利debug。

```java
public class Global {
		public static final boolean IS_DEBUG = true;
}
```

<u>Global中的靜態常數:</u>

將常數設在global以減少記憶體消耗。

```java
//視窗大小
public static final int WINDOW_WIDTH = 960;
public static final int WINDOW_HEIGHT = 640;
// 資料刷新時間
public static final int UPDATE_TIMES_PER_SEC = 60; //每秒更新60次遊戲邏輯
public static final int NANOSECOND_PER_UPDATE = 1000000000 / UPDATE_TIMES_PER_SEC; // 每一次要花費的奈秒數
// 畫面更新時間
public static final int FRAME_LIMIT = 60; //每秒更新60次畫面
public static final int LIMIT_DELTA_TIME = 1000000000 / FRAME_LIMIT; //每一次要花費的奈秒數
```

<u>Global中的靜態方法:</u>

將常用統一的方法設在global以減少記憶體消耗。

```java
//產生亂數
public static int random(int min, int max) {
		return (int) (Math.random() * (max - min + 1) + min);
}
//算機率
public static boolean random(int rate) {
		return random(1, 100) <= rate;
}
```





## Map Loader

### Map Info

### Map Loader

### ReadBmp

### Read File





## Camera

### Camera

### Map Information

### Small Map



## Internet

### Sever

### Sever Test

### Client Class

### Command Receiver

