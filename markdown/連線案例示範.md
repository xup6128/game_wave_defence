## 案例示範:

案例需求: 1.在首頁選擇建立伺服器(按下Enter)；或連接伺服器(按下Space)

​                  2.多人連線後，可以看見各自的角色行走。

![img](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/7f10da9e-11de-4e0c-acc7-1f5c0461348e/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210412%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210412T011309Z&X-Amz-Expires=86400&X-Amz-Signature=86bb619df9fc2ea5581ebe922d59eb863a2daaaba3dd8401f1e785ee416cada0&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

![img](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/61896fa0-843d-43d1-962b-d5fd0dc36168/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210412%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210412T012510Z&X-Amz-Expires=86400&X-Amz-Signature=21ef16b63c5e7eb0d43259a1bb3367feb9799e1b4fe6eee23f6dbd0e9b0a5e91&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

## 第一步:首頁的連線設置和基礎設置

### 1.在OpenScene設置創立伺服器 或 連接伺服器

```java
//在首頁場景中的keyListener()實作連線設置
@Override
public CommandSolver.KeyListener keyListener() { 
    return new CommandSolver.KeyListener() {
        @Override
        public void keyPressed(int commandCode, long trigTime) {
            Scanner sc=new Scanner(System.in);
                if ( commandCode == 0) { //按下enter時觸發建立伺服器
                    Server s=Server.instance(); //取得Server實體
                    s.create(12345); //建立伺服器，並可帶入port號當參數
                    s.start(); //啟動伺服器
                    try {
                        ClientClass.getInstance().connect("127.0.0.1",12345); //連接自己的伺服器
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    System.out.println("主機IP：" + Server.instance().getLocalAddress()[0] +  //印出主伺服器的資訊
                            "\n主機PORT：" + Server.instance().getLocalAddress()[1]);
                }else if(commandCode==5){  //按下space時觸發連接伺服器
                    System.out.println("請輸入IP:"); 
                    String str=sc.next();
                    try {
                        ClientClass.getInstance().connect(str,12345); //連接伺服器
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            ArrayList<String> str=new ArrayList<>();
            SceneController.getInstance().changeScene(new MapScene());
            }
        @Override
        public void keyReleased(int commandCode, long trigTime) {
				//沒有使用到，空方法體即可
        }
        @Override
        public void keyTyped(char c, long trigTime) {
				//沒有使用到，空方法體即可
        }
    };
}
```

### 2.為Actor加入ID屬性:

​    由於Server類會為每位加入的玩家配發一組ID，此範例我們在玩家控制的角色加入ID屬性，接收伺服器配發的ID以**標示玩家**。

```java
public class Actor extends GameObject{
    private int ID;//增加ID屬性，接收連線時伺服器發送的ID
    //其他屬性略...
  
    public Actor(int x, int y,int num) {
       //建構子略
    }
    //增加設置和取得Id的方法
    public void setId(int id){ 
        this.ID=id;
    }
    public int getId(){
        return this.ID;
    }
	//其他方法略
}
```



## 第二步:遊戲主場景的設置-傳送和接收訊息

### 1.在遊戲場景中加入Actor的集合:

```java
//在遊戲主場景中加入角色集合，
public class MapScene extends Scene {
  	
    private ArrayList<Actor> actor; //增加角色集合，如此才可以在有別人加進來時，將他人的角色加入到自己的ArrayList中，並出現在場景。
    
    public MapScene(){
    }
    
    @Override
    public void sceneBegin() { //開場時記得給角色設置ID
        actor=new ArrayList<>();
        actor.add(new Actor(Integer.parseInt(str.get(0)),Integer.parseInt(str.get(1)),num));
        ClientClass.getInstance().sent(Global.InternetCommand.CONNECT,str); //記得要傳送自己的座標位置等資訊!
        actor.get(0).setId(ClientClass.getInstance().getID());  //為自己的角色設置ID(自己的角色都會是集合中的第一個)。
        //其他略
    }
}
```

### 2.設置InternetCommand

​	可以在Global中設置InternetCommand，目前需求為連接玩家並看的見移動，然後離開時會斷線。

​	所以設置三個指令CONNECT  MOVE  DISCONNECT。將來有更多邏輯時，要視需求擴充，例如射擊遊戲就會有SHOT指令。

```java
//可以在Global中設置連線指令，如下
public class Global {
    public class InternetCommand{ 
        public static final int CONNECT=0; //連線的指令碼
        public static final int MOVE=1; //移動的指令碼
        public static final int DISCONNECT=2; //斷線的指令碼
    }
}
```

### 3.主場景中傳送和接收指令:

​      主要兩個步驟: 1.發送自己角色的訊息  2.接收並解析別人角色的連接 移動 斷線等訊息

#### - 發送訊息

(1)**在update中發送自己的ID 中心點座標x y 移動方向**

```java
//於主場景的update發送自己的相關訊息
@Override
    public void update() {
        actor.get(0).update();
        ArrayList<String> strr=new ArrayList<>(); //儲存訊息封包的集合
        strr.add(ClientClass.getInstance().getID()+""); //打包ID訊息
        strr.add(actor.get(0).painter().centerX()+"");//打包角色座標x
        strr.add(actor.get(0).painter().centerY()+"");//打包角色座標y
        strr.add(actor.get(0).getDir()+""); //打包角色方向
        ClientClass.getInstance().sent(Global.InternetCommand.MOVE,strr); //sent方法傳送資訊
    }
```

**(2)在鍵盤監聽中發送斷線訊息:**

```java
//在主場景的keyListener()發送斷線訊息
@Override
public CommandSolver.KeyListener keyListener() {
    return new CommandSolver.KeyListener(){
        @Override
        public void keyTyped(char c, long trigTime) {
			
        }
        public void keyPressed(int commandCode, long trigTime) {
            Global.Direction dir=Global.Direction.getDirection(commandCode);
            if(commandCode==6){  //角色斷線時發送斷線訊息
                ArrayList<String> strs = new ArrayList<String>(); //儲存訊息封包的集合
                strs.add(String.valueOf(ClientClass.getInstance().getID())); //打包ID
                ClientClass.getInstance().sent(Global.InternetCommand.DISCONNECT,strs); //傳送封包
                ClientClass.getInstance().disConnect(); //斷開伺服器連結
                System.exit(0); //結束程式
            }
```

#### - 接收訊息

接收並解析別人角色的連接 移動 斷線等訊息。這部分將會很長，藉由ClinetClass中的consume方法，就可以依據我們在Global中設置的InternetCommand，搭配switchCase來設定三種狀態下要解析的外來訊息。

```java
//在主場的update中處理訊息封包，並做出相應動作
@Override
public void update() {
    //傳送自己訊息的方法見發送訊息段...以上略
	//使用consume方法解析封包，並執行相應動作
    ClientClass.getInstance().consume(new CommandReceiver() {
        @Override
        public void receive(int serialNum, int internetcommand, ArrayList<String> strs) {
            switch(internetcommand){
                case Global.InternetCommand.CONNECT: //(1)完成CONNCENT指令的處理邏輯
                    System.out.println("Connect " + serialNum); //serialNum即客戶的ID
                    boolean isburn = false;
                    for (int i = 0; i < actor.size(); i++) { 
                        if (actor.get(i).getId() == serialNum) {
                            isburn = true; //避免已經加入過的玩家被加入角色陣列
                            break;
                        }
                    }
                    if(!isburn) { //將新進的玩家，加入自己的角色陣列中
                        actor.add(new Actor(Integer.parseInt(strs.get(0)),Integer.parseInt(strs.get(1)), 				
　　　　　　　　　　　　　　　							Integer.parseInt(strs.get(2))));
                        actor.get(actor.size() - 1).setId(serialNum);
                        ArrayList<String> str=new ArrayList<>(); 
                        str.add(actor.get(0).painter().centerX()+"");
                        str.add(actor.get(0).painter().centerY()+"");
                        str.add(actor.get(0).getNum()+"");
                        ClientClass.getInstance().sent(Global.InternetCommand.CONNECT,str);//並傳送自己的資訊給所有人
                    }
                    break;
                case Global.InternetCommand.MOVE: //(2)完成MOVE指令的處理邏輯
                    for(int i=1;i<actor.size();i++) {
                        if(actor.get(i).getId()==Integer.parseInt(strs.get(0))) {
                           actor.get(i).painter().setCenter(Integer.parseInt(strs.get(1)),Integer.parseInt(strs.get(2)));
                            actor.get(i).collider().setCenter(Integer.parseInt(strs.get(1)),Integer.parseInt(strs.get(2)));
                           actor.get(i).walk(Global.Direction.getDirection(Integer.parseInt(strs.get(3))));
                           break;
                        }
                    }
                    break;
                case Global.InternetCommand.DISCONNECT: //(3)完成DISCONNENT的處理邏輯
                    for(int i=0;i<actor.size();i++){ //接收到有人斷現的訊息時，就從我們的Actor陣列中比對ID，移除該Actor
                        if(actor.get(i).getId()==Integer.parseInt(strs.get(0))){
                           actor.remove(i);
                           i--;
                           break;
                        }
                    }
                    break;
            }
        }
    });
}
```

### 4. 最後的主場景繪製

```java
 //	記得在paint中把大家的角色都畫出來
 @Override
    public void paint(Graphics g) {
        for(int i=0;i<actor.size();i++){
            actor.get(i).paint(g);
      
        }
    }
```

